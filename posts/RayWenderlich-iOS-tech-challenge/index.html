<!DOCTYPE html><html lang="en"><head><title>The Ray Wenderlich iOS Technical Challenge | Andrew Marmion</title><meta name="twitter:title" content="The Ray Wenderlich iOS Technical Challenge | Andrew Marmion"/><meta name="og:title" content="The Ray Wenderlich iOS Technical Challenge | Andrew Marmion"/><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"/><link rel="stylesheet" href="/styles.css"/><link rel="shortcut icon" type="image/png" href="/Images/favicon.png"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">Andrew Marmion</a><p class="description">Coding carefully, deliberately, and with humility.</p><nav><ul><li><a href="/About">About</a></li><li><a class="selected" href="/posts">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><div><div class="title">The Ray Wenderlich iOS Technical Challenge</div><ul class="tag-list"><li><a class="tag variant-0" href="/tags/article">Article</a></li><li><a class="tag variant-1" href="/tags/catalysy">Catalysy</a></li><li><a class="tag variant-2" href="/tags/ios">iOS</a></li><li><a class="tag variant-2" href="/tags/ipados">iPadOS</a></li><li><a class="tag variant-2" href="/tags/macos">macOS</a></li><li><a class="tag variant-5" href="/tags/swiftui">SwiftUI</a></li></ul><p class="published">Published on 13 October 2021</p></div><div class="content"><p>One of the steps when applying for an iOS job is to complete a technical challenge/assignment. Now I am not going to get into a discussion about whether this is a good thing or not.</p><p>As part of my job I review technical challenges (the one that we ask our candidates to complete is somewhat similar to the Ray Wenderlich challenge), and many have come across my desk ranging from the wonderful to the what-the-hell-is-going-on-here.</p><p>Ray Wenderlich has an interview practice project on their GitHub, you can find it <a href="https://github.com/raywenderlich/ios-interview/tree/master/Practical%20Example">here</a>.</p><p>Here are there requirements for the project</p><p><em>To pass the test, the app has to include the following:</em></p><ul><li>Fetch articles and video courses and display them once both networking calls have finished.</li><li>For each item (article or video course) you have to display <strong>at least</strong>: <em>Name</em>, <em>Artwork</em>, <em>Description</em>, <em>Type (article or video)</em></li><li>The results should be sorted by release date.</li><li>There should be a way to view <em>Only articles</em>, <em>Only videos</em>, <em>Both</em></li></ul><h2>My Implementation</h2><p>This weekend, I decided to do my own take on the challenge. Instead of completing it using UIKit I decided to use SwiftUI, and instead of making it with one application I decided to build separate apps for iOS, iPadOS and macOS. So I fired up Xcode 13, selected a multiplatform project and started to prototype.</p><p>The first thing I looked at was the JSON that the APIs were delivering, the <a href="https://raw.githubusercontent.com/raywenderlich/ios-interview/master/Practical%20Example/articles.json">articles</a> and the <a href="https://raw.githubusercontent.com/raywenderlich/ios-interview/master/Practical%20Example/videos.json">videos</a>, and to see what a model would look like that represented each of them. Both endpoints use the same model response so I decided to use the same one for each this gave the following:</p><pre><code><span class="keyword">struct</span> FeedItems: <span class="type">Decodable</span> {
    <span class="keyword">let</span> data: [<span class="type">FeedItem</span>]
}

<span class="keyword">struct</span> FeedItem: <span class="type">Decodable</span>, <span class="type">Identifiable</span> {
    <span class="keyword">let</span> id: <span class="type">String</span>
    <span class="keyword">let</span> attributes: <span class="type">ItemAttributes</span>
}

<span class="keyword">struct</span> ItemAttributes: <span class="type">Decodable</span> {
    <span class="keyword">let</span> name: <span class="type">String</span>
    <span class="keyword">let</span> description: <span class="type">String</span>
    <span class="keyword">let</span> content_type: <span class="type">ContentType</span>
    <span class="keyword">let</span> card_artwork_url: <span class="type">URL</span>
}

<span class="keyword">enum</span> ContentType: <span class="type">String</span>, <span class="type">Decodable</span> {
    <span class="keyword">case</span> article
    <span class="keyword">case</span> video = <span class="string">"collection"</span> <span class="comment">// videos are denoted collection in the JSON</span>
}
</code></pre><br /><p>Once I had the model sorted I decided to create a very simple <code>ViewModel</code> that made a network request and published an array of the decoded models.</p><pre><code><span class="keyword">class</span> ViewModel: <span class="type">ObservableObject</span> {

    <span class="keyword">@Published var</span> state: [<span class="type">FeedItem</span>] = []

    <span class="keyword">private var</span> cancellables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()

    <span class="keyword">init</span>() {
        <span class="call">load</span>()
    }

    <span class="keyword">func</span> load() {

        <span class="keyword">let</span> articlesURL = <span class="type">URL</span>(string: <span class="string">"https://raw.githubusercontent.com/raywenderlich/ios-interview/master/Practical%20Example/articles.json"</span>)!

        <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTaskPublisher</span>(for: articlesURL)
            .<span class="call">tryMap</span> { $0.<span class="property">data</span> }
            .<span class="call">decode</span>(type: <span class="type">FeedItems</span>.<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())
            .<span class="call">sink</span> { completion <span class="keyword">in
                switch</span> completion {
                <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
                    <span class="keyword">self</span>?.<span class="property">state</span> = .<span class="call">error</span>(error)
                <span class="keyword">case</span> .<span class="dotAccess">finished</span>:
                    <span class="keyword">break</span>
                }

            } receiveValue: { [<span class="keyword">weak self</span>] items <span class="keyword">in
                self</span>?.<span class="property">items</span> = items
            }
            .<span class="call">store</span>(in: &amp;cancellables)
    }
}
</code></pre><br /><p>This meant that I could quickly make sure that I was correctly decoding the JSON and that I was getting the correct response.</p><p>Next I made up a quick view that showed a simple list.</p><pre><code><span class="keyword">struct</span> Content: <span class="type">View</span> {

    <span class="keyword">@StateObject var</span> viewModel = <span class="type">ViewModel</span>()
    <span class="keyword">let</span> items: [<span class="type">FeedItem</span>]

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>(viewModel.<span class="property">items</span>) { item <span class="keyword">in</span>
                <span class="type">Text</span>(item.<span class="property">attributes</span>.<span class="property">name</span>)
            }
        }
    }
}
</code></pre><br /><p>With the data being loaded into the view correctly I furthered the prototype so that I could display a list that I could reuse. I also added some state management to my <code>ViewModel</code> which would allow different views to be shown when the view was loading, loaded and if it had encountered an error.</p><p>This is what I came up with.</p><h3>ViewModel</h3><pre><code><span class="keyword">enum</span> LoadingState {
    <span class="keyword">case</span> loading
    <span class="keyword">case</span> loaded([<span class="type">FeedItem</span>])
    <span class="keyword">case</span> error(<span class="type">Error</span>)
}


<span class="keyword">class</span> ViewModel: <span class="type">ObservableObject</span> {

    <span class="keyword">@Published var</span> state: <span class="type">LoadingState</span> = .<span class="dotAccess">loading</span>

    <span class="keyword">private var</span> cancellables = <span class="type">Set</span>&lt;<span class="type">AnyCancellable</span>&gt;()

    <span class="keyword">init</span>() {
        <span class="call">load</span>()
    }

    <span class="keyword">func</span> load() {

        <span class="keyword">let</span> articlesURL = <span class="type">URL</span>(string: <span class="string">"https://raw.githubusercontent.com/raywenderlich/ios-interview/master/Practical%20Example/videos.json"</span>)!

        <span class="type">URLSession</span>.<span class="property">shared</span>.<span class="call">dataTaskPublisher</span>(for: articlesURL)
            .<span class="call">tryMap</span> { $0.<span class="property">data</span> }
            .<span class="call">decode</span>(type: <span class="type">FeedItems</span>.<span class="keyword">self</span>, decoder: <span class="type">JSONDecoder</span>())
            .<span class="call">sink</span> { completion <span class="keyword">in
                switch</span> completion {
                <span class="keyword">case</span> .<span class="dotAccess">failure</span>(<span class="keyword">let</span> error):
                    <span class="keyword">self</span>.<span class="property">state</span> = .<span class="call">error</span>(error)
                <span class="keyword">case</span> .<span class="dotAccess">finished</span>:
                    <span class="keyword">break</span>
                }

            } receiveValue: { [<span class="keyword">weak self</span>] value <span class="keyword">in
                self</span>?.<span class="property">state</span> = .<span class="call">loaded</span>(value.<span class="property">data</span>)
            }
            .<span class="call">store</span>(in: &amp;cancellables)

    }
}
</code></pre><br /><h3>The Views</h3><br /><ul><li>ContentView</li></ul><br /><pre><code><span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="keyword">switch</span> viewModel.<span class="property">state</span> {
        <span class="keyword">case</span> .<span class="dotAccess">error</span>(<span class="keyword">let</span> error):
            <span class="type">Text</span>(<span class="string">"Loading error</span> \(error.<span class="property">localizedDescription</span>)<span class="string">"</span>)
        <span class="keyword">case</span> .<span class="dotAccess">loaded</span>(<span class="keyword">let</span> items):
            <span class="type">ListView</span>(items: items)
        <span class="keyword">case</span> .<span class="dotAccess">loading</span>:
            <span class="type">Text</span>(<span class="string">"Loading"</span>)
        }
    }
}
</code></pre><br /><ul><li>ListView</li></ul><br /><pre><code><span class="keyword">struct</span> ListView: <span class="type">View</span> {
    <span class="keyword">let</span> items: [<span class="type">FeedItems</span>.<span class="type">FeedItem</span>]

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span> {
            <span class="type">ForEach</span>(items) { item <span class="keyword">in</span>
                <span class="type">VStack</span>(alignment: .<span class="dotAccess">leading</span>) {
                    <span class="type">HStack</span>(alignment: .<span class="dotAccess">top</span>) {
                        <span class="type">ItemImage</span>(url: item.<span class="property">attributes</span>.<span class="property">card_artwork_url</span>)
                            .<span class="call">clipShape</span>(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">8</span>))
                            .<span class="call">frame</span>(width: <span class="number">100</span>, height: <span class="number">100</span>)

                        <span class="type">VStack</span>(alignment: .<span class="dotAccess">leading</span>, spacing: <span class="number">10</span>) {
                            <span class="type">Text</span>(item.<span class="property">attributes</span>.<span class="property">name</span>)
                                .<span class="call">fixedSize</span>(horizontal: <span class="keyword">false</span>, vertical: <span class="keyword">true</span>)
                            <span class="type">Image</span>(systemName: <span class="call">getImageName</span>(for: item.<span class="property">attributes</span>.<span class="property">content_type</span>))
                        }

                        <span class="type">Spacer</span>()
                    }

                    <span class="type">Text</span>(item.<span class="property">attributes</span>.<span class="property">description</span>)
                        .<span class="call">fixedSize</span>(horizontal: <span class="keyword">false</span>, vertical: <span class="keyword">true</span>)
                }
            }
        }
    }

    <span class="keyword">func</span> getImageName(for contentType: <span class="type">ContentType</span>) -&gt; <span class="type">String</span> {
        <span class="keyword">switch</span> contentType {
        <span class="keyword">case</span> .<span class="dotAccess">article</span>:
            <span class="keyword">return</span> <span class="string">"doc.text"</span>
        <span class="keyword">case</span> .<span class="dotAccess">video</span>:
            <span class="keyword">return</span> <span class="string">"film"</span>
        }
    }
}
</code></pre><br /><ul><li>ItemImage</li></ul><br /><pre><code><span class="keyword">struct</span> ItemImage: <span class="type">View</span> {
    <span class="keyword">let</span> url: <span class="type">URL</span>
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">AsyncImage</span>(url: url) { image <span class="keyword">in</span>
            image
                .<span class="call">resizable</span>()
                .<span class="call">scaledToFit</span>()
        } placeholder: {
            <span class="type">ZStack</span> {
                <span class="type">ProgressView</span>()
                <span class="type">Color</span>.<span class="property">gray</span>.<span class="call">opacity</span>(<span class="number">0.1</span>)
            }
        }
    }
}
</code></pre><br /><p>I now had a very basic prototype from which I could work from. I tested it on both iPhone and iPad, it worked as expected. I went to try it on the mac, this is where I ran into a problem. <code>AsyncImage</code> is not available for my mac. My mac is currently on 11.6, while <code>AsyncImage</code> is available for <code>macOS 12.0+</code> so I couldn't use <code>AsyncImage</code>, and I would have to roll-my-own solution.</p><p>When building crossplatform applications it can lead to spaghetti code where you have many <code>#if os()</code> or <code>if #available()</code> statements taking you down multiple paths. I didn't want to do this. I wanted to have my views as clean and clear as possible. So I weighed up the options and decided that I would have different files per target. That meant there would be a small amount of duplication, but I felt that this was offset by the clarity in the code.</p><p>Once I had gotten the code to compile, There was another thing stopping the mac app from working: it did not have the <code>com.apple.security.network.client</code> entitlement set. This meant that all network requests would automatically fail. Realising my mistake, I gave the app the entitlement and it started working on the mac.</p><p>I felt that I was in a good place. I had a working prototype that showed a list of the items. The next step was to make both network requests and to have the ability to show all the items, only the articles, or only the videos.</p><p>For iOS I decided on using a segmented controller, for iPad and mac, I would eventually decide on using the sidebar.</p><p>Here is what my completed applications look like:</p><p><a href="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/iphone.png"><img src="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/iphone.png" alt="ios app" style="width:400px;" /></a></p><p><a href="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/ipad.png"><img src="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/ipad.png" alt="ipad app" style="width:400px;" /></a></p><p><a href="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/mac.png"><img src="https://raw.githubusercontent.com/andrewmarmion/PracticalExample/main/README_ASSETS/mac.png" alt="mac app" style="width:400px;" /></a></p><p>For the completed project you can find it <a href="https://github.com/andrewmarmion/PracticalExample">here</a></p><br /><hr><br /><h1>Gotchas</h1><p>Along the way, while building this I came across several gotchas:</p><h2>AsyncImage</h2><p>This is only available for macOS 12.0+, so I wasn't able to use this and had to write my own solution. <a href="https://github.com/andrewmarmion/PracticalExample/blob/main/Shared/Repositories/Image%20API/RemoteImageLoader.swift">1</a></p><h2>Sidebar</h2><p>To be able to toggle the sidebar on macOS I had to reach into the <code>NSApp.keyWindow</code> to make that work. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Views/ContentView/ContentView_macOS.swift#L29">2</a></p><h2>Dates</h2><p>Again this was an issue with my mac not being on macOS 12, I couldn't use the formatted option for displaying the date. Instead I had to create my own date formatter. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Helpers/Helpers_macOS.swift#L10">3</a></p><h2>NavigationView</h2><p>The <code>NavigationView</code> worked as expected on iOS but on the iPad and mac it would put the <code>List</code> that I was trying to present into the <code>SideBar</code> to avoid this I had to create a custom <code>SideBarView</code> so that I could make sure that <code>NavigationView</code> would work as expected. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Views/SideBarView.swift#L10">4</a></p><h2>Hiding the SegmentedControl on iOS</h2><p>To hide this I had to make use of size classes and reach into the <code>environment</code> to get the <code>horizontalSizeClass</code> for the device. This meant that I could show and hide the SegementedControl. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Views/LoadedView/LoadedView_iOS.swift#L17">5</a></p><h2>The difference between UIImage and NSImage</h2><p>iOS and iPadOS use UIImage, whereas macOS uses NSImage. I had to create a typealias <code>PEImage</code> that would allow me to use <em>one</em> image type through out the application. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Repositories/Image%20API/ImageLoader.swift#L13">6</a></p><p>I also had to make use of <code>#if os(...)</code> inside the <code>ItemImageView</code> as the initializers for <code>Image</code> accept either an <code>UIImage</code> or an <code>NSImage</code>. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/Shared/Views/ItemImageView.swift#L32">7</a></p><p>I could have done the following which would have cleaned the code up:</p><pre><code><span class="keyword">extension</span> <span class="type">Image</span> {
    <span class="keyword">init</span>(peImage: <span class="type">PEImage</span>) {
        <span class="preprocessing">#if os(iOS)</span>
        <span class="keyword">self</span>.<span class="keyword">init</span>(uiImage: peImage)
        <span class="preprocessing">#elseif os(macOS)</span>
        <span class="keyword">self</span>.<span class="keyword">init</span>(nsImage: peImage)
        <span class="preprocessing">#endif</span>
    }
}
</code></pre><br /><p>This would have allowed me to use the one initializer and remove the <code>#if os(..)</code> from the view hierarchy.</p><h2>Constructing NSImage programatically</h2><p>When I am testing anything that uses images, I prefer to use a programatic image. A programatic image means that there is no I/O operation and it doesn't rely on an image being present in the assets. Unforuntately I was unable to construct NSImage programatically, as my knowledge of <code>Cocoa</code> is more limited so I had to resort to using an image in the assets. <a href="https://github.com/andrewmarmion/PracticalExample/blob/a5241bcd2e6ddc68115c2352c96cd6b796c5129a/PracticalExampleTests_macOS/Helpers/NSImage%2BTestHelpers.swift#L3">8</a></p><h2>URLProtocol and publishers</h2><p>When using URLProtocol to inject the networking response that I want, I was having difficulty getting the injected error that I was expecting. This meant that I couldn't write the test that I wanted to write, that showed that if I stubbed a specific error that I would get that error. I had to be content with just getting an error. This was the first time that I was using publishers with URLProtocol, I think it warrants some additional time in the future to make sure that I can get the correct error.</p></div></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p>Copyright © Andrew Marmion 2021</p><div><a href="https://twitter.com/IamThatAndrew" class="fa fa-twitter"></a><a href="https://github.com/andrewmarmion" class="fa fa-github"></a><a href="https://linkedin.com/in/andrewmarmion" class="fa fa-linkedin"></a><a href="https://stackoverflow.com/users/5508175/andrew?tab=profile" class="fa fa-stack-overflow"></a><a href="https://youtube.com/c/andrewmarmion" class="fa fa-youtube"></a></div></footer></body></html>